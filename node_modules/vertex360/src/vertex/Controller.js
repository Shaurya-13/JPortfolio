const path = require('path')
const fs = require('fs')

const BASE_DIR = __dirname + '/../../../../'
const TMP_DIR = process.env.TMP_DIR || '/tmp'
const LOCAL_DIR = path.join(BASE_DIR, TMP_DIR)
const defaultMethods = ['constructor', 'get', 'getById', 'post', 'put', 'delete']
let _TURBO_ENV, _TURBO_API_KEY, _turbo = null

class Controller {
  constructor(schema, env){
    this._schema = schema // Job, Post, Profile, etc
    _turbo = require('turbo360')({site_id: env.TURBO_APP_ID})
    _TURBO_API_KEY = env.TURBO_API_KEY
    _TURBO_ENV = env.TURBO_ENV

    this.hooks = {
        find: (collectionName) => {
			return new Promise((resolve, reject) => {
				// console.log('FIND HOOK: ')
				Controller.checkCollectionDB(collectionName)
				.then(data => {
					resolve(data)
				})
				.catch(err => {
					reject(err)
				})
			})
		},
		save: (collectionName) => {

			// TODO: this should be converted to an a task in a task queue:
			return new Promise((resolve, reject) => {
				// console.log('SAVE HOOK: ')
				Controller.syncCollection(collectionName)
				.then(data => {
					resolve(data)
				})
				.catch(err => {
					reject(err)
				})
			})
		}
    }

	const props = Object.getOwnPropertyNames(Object.getPrototypeOf(this))
	const _this = this
	props.forEach(funcName => {
		// this is a custom method added by developer:
		if (typeof this[funcName] !== 'function')
			return

		if (defaultMethods.indexOf(funcName) > -1){
			if (funcName=='constructor')
				return

			const originalFunc = this[funcName]
			if (funcName=='get' || funcName=='getById'){
				this[funcName] = async function(){
					// console.log('TEST!!!! '+JSON.stringify(...arguments))
					const data = await _this.hooks.find(_this.collectionName())
					return originalFunc(...arguments)
				}
			}
			else {
				this[funcName] = async function(){
					// console.log('TEST!!!! '+JSON.stringify(...arguments))
					const payload = await originalFunc(...arguments)
					if (_TURBO_ENV !== 'prod')
						return payload

					try {
						const a = await _this.hooks.save(_this.collectionName())
						return payload
					}
					catch(err){
						return payload
					}
				}
			}

			return
		}
		
		// console.log('CONSTRUCTOR FUNCTION: ' + funcName)
		const originalFunc = this[funcName]
		this[funcName] = async function() {
			// console.log('ARGUMENTS: '+JSON.stringify(arguments))
			const data = await _this.hooks.find(_this.collectionName())
			const payload = await originalFunc(...arguments)

			if (_TURBO_ENV !== 'prod')
				return payload

			try {
				const a = await _this.hooks.save(_this.collectionName())
				return payload
			}
			catch(err){
				return payload
			}
		}
	})
  }

  static checkCollectionDB(collectionName) {
  	const collectionFilePath = (_TURBO_ENV=='dev') ? LOCAL_DIR+'/'+collectionName+'.db' : TMP_DIR+'/'+collectionName+'.db'

  	return new Promise((resolve, reject) => {
  		_turbo.checkCollectionFile(collectionName, collectionFilePath)
  		.then(data => { // load collection file from backing store if necessary
  			return (data.found) ? null : _turbo.loadCollection(collectionName, collectionFilePath, _TURBO_API_KEY)
  		})
  		.then(data => {
  			resolve(data)
  		})
  		.catch(err => {
  			reject(err)
  		})
  	})
  }

  static syncCollection(collectionName) {
    const filePath = (_TURBO_ENV=='dev') ? LOCAL_DIR + '/'+collectionName+'.db' : TMP_DIR+'/'+collectionName+'.db'
  	return _turbo.syncCollection(collectionName, filePath, _TURBO_API_KEY)
  }

  static parseFilters(params) {
    if (params == null)
      return null

    const filters = {}
    filters['sort'] = (params.sort == 'asc') ? 'timestamp' : '-timestamp'
    delete params['sort']

    filters['limit'] = (params.limit) ? parseInt(params.limit) : 0
    delete params['limit']
    return filters
  }

	collectionName() {
		return this._schema.collectionName()
	}

	schema() {
		return this._schema.schema()
	}

  	get(params) {
		return null
	}

	getById(id) {
		return null
	}

	post(body) {
		return null
	}

	put(id, params) {
		return null
	}

	delete(id) {
		return null
	}

}

module.exports = Controller
